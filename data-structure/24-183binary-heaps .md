##### binary heap

최대 두개의 자식이므로 binary.
max binary heap에서는 부모값이 항상 자식 값보다 큰 값을 가짐
min binary heap에서는 그 반대. 부모가 언제나 자식보다 작음
형제들 사이에서는 특별한 순서가 없음
이진힙은 언제나 최적의 용량을 가짐
왼쪽 자식이 먼저 채워짐
배워야 하는 이유 힙을 사용해 우선순위 큐를 만듦

#### insert 구현하기 설명

constructor에 필요한 것은 value프로퍼티의 빈 리스트
배열에 저장해서 그 위치를 기반으로 구조를 모형화
왼쪽에서 오른쪽으로 채움
배열구조에서 봤을 때는 매번 리스트에 push를 함
가장 큰 수를 추가하면 맨 뒤에 추가하고 그다음 bubble up 해야함
(부모값보다 최근 추가한 수가 크면 부모값과 swap)

### 순서

삽입하기 (왼쪽먼저 추가, 다음 오른쪽)
배열 맨뒤에 push로 추가하게 되면
위와같은 순서로 추가하게 되는 것
그다음 부모값을 찾음
부모값과 삽입한 값 비교
삽입값이 크면 부모값과 swap
swap하고 나서 새로운 부모값과 비교
삽입값이 크면 부모값과 swap
삽입값이 작으면 그자리에 위치

## insert pseudocode

> insert에 bubbleUp메서드 내용도 함께 추가하든지,
> 혹은 버블업이라는 메서드를 새로 호출
>
> > bubbleUp은 values 리스트 또는 배열의 맨 뒤에
> > 값을 push한 뒤에 실행되어야 함

1. 마지막 인덱스에있는 요소 선택 : element?
2. 해당 인덱스로 부모의 자리를 찾음 : parent
   (index-1)/2 내림한 값
3. select와 parent를 비교
   select> parent면 select와 parent swap
4. 1번부터 select> parent일때까지만 반복하여 swap
5. parent가 없으면 stop해야 함

#### ExtractMax 구현하기 설명

MaxBinaryHeaps에서 보통 제거하는 것은 최댓값이다.
MinBinaryHeaps에서 보통 제거하는 것은 최솟값이다.
그냥 제거하지 않고 새로운 루트를 선택해줘야 하는데,
루트를 제거하고 가장 맨뒤에 있는 값과 바꿔준다.
그리고는 sink down을 호출 해서 제자리에 놓는다.
자식과 비교해 루트에 있는 수가 작으면 스왑(두개의 자식중 더 큰수와 비교 )
새로운 자식과 또 비교해 맞을때까지 스왑한다.

### 순서

삭제할 루트와 맨 마지막 배열의 값과 스왑하고 삭제할 루트는 삭제
루트의 숫자와 다음 배열의 숫자 둘 중 큰 수와 비교하여
루트가 작으면 변경
계속 새로운 자식과 비교하여 루트가 작으면 변경
삭제한 값 return

## ExtractMax pseudocode

> binary heap class에 메서드 작성 (이름은 extractMaximum등 자유)

1. first value를 선택하고 last value와 자리를 바꾼다.
2. pop을 사용하여 마지막의 value를 삭제 (이 값을 저장하여 return)
3. sink down... index 0 에서부터 시작해서 가라앉음
4. 해당 인덱스의 왼쪽과 오른쪽 자식을 찾음
5. 왼쪽 자식 : 2 \* index + 1 (범위에서 벗어나지 않는지 확인)
6. 오른쪽 자식 : 2 \* index + 2 (범위에서 벗어나지 않는지 확인)
7. 왼쪽 자식과 오른쪽 자식과 부모를 비교해 부모보다 더 큰수와 부모와 스왑
8. 둘다 부모보다 크다면 큰 수의 자식과 부모를 스왑
9. 자리 바꾸고 난 뒤. 자리를 바꾼 자식의 인덱스를 새로운 부모의 인덱스로 설정
10. 계속 자식을 또 찾아서 루프
11. 두 자식이 해당 요소보다 크지 않을 때까지.
12. 이전 루트를 출력.
