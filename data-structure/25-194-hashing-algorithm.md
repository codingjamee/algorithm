##### 해시 알고리즘이란?

해시테이블에서 충돌이 일어나는 경우
충돌이 무슨 의미인지
충돌을 해결하는 두가지 방법
개별체이닝, 선형 조사법

해시 테이블은 키-값 쌍을 저장하는데 사용됨
해시 테이블의 키는 순서를 가지지 않음

해시 테이블은 삭제, 추가, 찾기가 매우 빠름
(배워야 하는 이유이기도)

#### 구현하기 설명

입력값을 받아들임
(현재는 string으로 범위 한정)
입력값을 숫자로 바꿔서 배열에 저장할 방법이 필요
입력값을 숫자로 바꾸는 작업 : 해시함수가 함
(해시함수는 많은 곳에 사용됨)

string을 받아서 숫자로 바꿈
같은 string을 받으면 같은 숫자로 바꿔야 함.
그래야 찾을 수도 있음

### hash 함수

스트링 키를 배열에서 사용되는 유효한 작은 인덱스로 바꾸는 역할.
정보 보호, 저장, 사이트 로그인 인증 등에 도움이 되며
암호 기술을 사용하는 암호화폐에서도 사용됨
해시 함수의 종류는 아주 많은데, 그 중에 하나는 암호화 해시 함수라고 불림.

정의 :
(수백, 수천 자의)임의의 크기를 가지는 데이터를 입력하면
정해진 크기의 데이터를 출력하는 함수
반대로 해시값으로 스트링 키를 출력할 수는 없음
이 해시값그대로 배열의 칸에 저장하는 것은 아님

좋은 해시 함수란 :

1. 빨라야 함 (상수값)
   삽입, 삭제, 검색할 때마다 해시 함수를 사용해야 하므로
2. 겹치지 말아야 함
3. 결정론적이다 (같은 값 입력 => 같은 출력)

## hash 함수 예시

해시화 될 스트링 키를 입력, 배열의 길이도 입력
"a".charCodeAt(0);

> charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수를 반환합니다.

```javascript
function hash(key, arrayLen) {
  let total = 0;
  for (let i = 0; i < key.length; i++) {
    let char = key[i];
    let value = char.charCodeAt(0) - 96;
    total = (total + value) % arrayLen;
  }
  return total;
}
```

## hash함수 개선 사항

string에 대해서만 해시처리를 함
상수 시간을 가지지 않음
(큰 스트링을 입력하면 더 오래 걸림)

```javascript
function hash(key, arrayLen) {
  let total = 0;
  let WEIRD_PRIME = 31;
  for (let i = 0; i < Math.min(key.length, 100); i++) {
    let char = key[i];
    let value = char.charCodeAt(0) - 96;
    total = (total + value) % arrayLen;
  }
  return total;
}
```

키의 길이와 100에 대해 작은 값에 대해 루프를 돌게 함
(적어도 100글자까지만 봄)
배열의 길이가 긴 것이 충돌이 일어날 확률이 적음
배열의 길이가 소수일 때 충돌 확률을 줄일 수가 있음

## 충돌 해결하기

1. 개별 체이닝 (separate chaining)
   배열이나 연결 리스트 등과 같은 것을 사용하여
   이중 데이터 구조를 사용하여 공동저장함
   그러면 해당 인덱스에 저장된 값을 루프를 돌아
   해당 값을 찾으면 됨. (중첩배열이 됨)
2. 직선 탐색법 (linear searching)
   각 데이터에 하나의 데이터만 저장한다는 규칙을 살림
   충돌이 일어나면 해당 데이터의 다음 값에 저장

## hashTable class 만들기

1. set
   키 하나와 값을 받음
   키를 해시화 함
   해당 해시키에 값이 없으면 그냥 저장
   그러나 중첩 구조에 저장 해야함
   (충돌시)개별 체이닝을 함
   psuedo code :
   키-값 쌍을 하나를 입력
   키를 해시한 다음에 키 값쌍을 개별 체이닝을 통해 해시 테이블에 저장

2. get
   키를 입력받음
   입력받은 키를 해시화 함
   해시함수에 의해 숫자가 나오면
   값을 얻고 나면 keyMap배열의 인덱스에 해당하는 자리로 감
   그리고 루프를 돌면서 해당 값을 확인
   값이 없으면 undefined
   값이 있으면
   전체 키-값 쌍을 출력

3. keys
   테이블에 있는 모든 키를 포함한 목록을 출력

4. values
   한 배열에 모든 값을 다 모아서 해당 배열을 출력
   겹치는 값들은 한번만 출력하게 할 것
   (유니크 밸류들만 출력)

## hashTable의 bigO

해시함수가 얼마나 빠른지, 충돌을 얼마나 줄였는지에 따라
달려있음 아래의 big O는 좋은 프로그래밍 언어에서의 시간복잡도

insert : O(1)
deletion: O(1)
Access : O(1)
